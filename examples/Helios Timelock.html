
<!DOCTYPE html>
<html lang="en">

<head>
    <title>Helios Timelock</title>
    <meta name="title" content="Helios Timelock">
    <meta name="description" content="Builds an Helios Smart Contract on the fly. First transaction will lock coins setting main staking key as owner, second one will be able to unlock it only after some time and using main spending key. Burner/Gift wallets not recommended. Timelock not exactly tested.">

    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#6d41a1" />

    <!-- 
        For gzip and base64url encodings no external dependencies are required, it's 100% browser native code. In other words: 
        GCWallet is the first wallet that doesn't inject code into websites and that has also zero-dependencies integrations
        For json-url-lzma encoding, this is the only dependency: 
    -->
    <script type="text/javascript" src="https://unpkg.com/json-url@3.1.0/dist/browser/json-url.js"></script>  

    <script>
        let handleSetEncoder;

        ///////////////////////////
        ////    Dapp Logic    /////
        ///////////////////////////
        async function main() {
            //Dapp <--> GameChanger Wallet connections can use URL redirections
            let   actionUrl   = "";
            let   resultObj   = undefined;
            let   error       = ""; 
            let   useCodec    = 'gzip';

            //GameChanger Wallet is pure Web3, zero backend procesing of user data. 
            //Dapp connector links are fully processed on end-user browsers.
            const gcApiUrl    = "http://localhost:3000/api/2/run/";
            const currentUrl  = window.location.href;

            //UI components:
            const connectForm = document.getElementById("dappConnectorBox");
            const actionBtn   = document.getElementById("connectBtn");
            const errorsBox   = document.getElementById("errorBox");
            const resultsBox  = document.getElementById("resultBox");
            const encodersBox = document.getElementById("encodersBox");

            //here we register a function to change connection encoding/compression
            handleSetEncoder=(codec)=>{
                useCodec=codec;
                updateUI();
                return false;
            }
            async function updateUI() {
                error="";
                actionUrl="";

                //GameChanger Wallet support arbitrary data returning from script execution, encoded in a redirect URL
                //Head to http://localhost:3000/doc/api/v2/api.html#returnURLPattern to learn ways how to customize this URL

                //lets try to capture the execution results by decoding/decompressing the return URL
                try{                
                    const resultRaw   = (new URL(currentUrl)).searchParams.get("result");
                    if(resultRaw){
                        resultObj     = await gcDecoder(resultRaw);
                        //avoids current url carrying latest results all the time 
                        history.pushState({}, '', window.location.pathname);
                    }
                }catch(err){
                    error+=`Failed to decode results.${err?.message||"unknown error"}`;
                    console.error(err);
                }


                //This is the GCScript code, packed into a URL, that GameChanger Wallet will execute
                //lets try to generate this connection URL by encoding/compressing the gcscript code
                try{                
                    //GCScript (dapp connector code) will be packed inside this URL    
                    actionUrl   = await buildActionUrl(); 
                }catch(err){
                    error+=`Failed to build URL.${err?.message||"unknown error"}`
                    console.error(err);
                }
                
                //Now lets render the current application state
                if(error){
                    errorBox.innerHTML="Error: " + error;
                }
                if(actionUrl){
                    errorBox.innerHTML="";
                    actionBtn.href=actionUrl;
                    actionBtn.innerHTML = `Connect`;
                }else{
                    actionBtn.href      = '#';
                    actionBtn.innerHTML = "Loading...";
                }

                if(resultObj){
                    resultsBox.innerHTML=JSON.stringify(resultObj,null,2);
                }
                encodersBox.innerHTML="Encoding: "
                encodersBox.innerHTML+=Object.keys(codecs)
                    .map(codec=>`<a href="#" class="a-unstyled" ${codec===useCodec?'style="font-weight:bold;""':''} onclick="return handleSetEncoder('${codec}')">${codec}</a>`)
                    .join(" | ");               

            }

            async function buildActionUrl(args){
                //This is the GCScript code that GameChanger Wallet will execute
                //JSON code that will be encoded/compressed inside 'actionUrl'
                var gcscript = {
  "title": "Helios Timelock",
  "description": "Builds an Helios Smart Contract on the fly. First transaction will lock coins setting main staking key as owner, second one will be able to unlock it only after some time and using main spending key. Burner/Gift wallets not recommended. Timelock not exactly tested.",
  "type": "script",
  "run": {
    "dependencies": {
      "type": "script",
      "run": {
        "stakeCredential": {
          "type": "data",
          "value": "ad03a4ae45b21f50fde67956365cff94db41bc08a2c2862403d8a234"
        },
        "beneficiary": {
          "type": "getSpendingPublicKey"
        },
        "owner": {
          "type": "getStakingPublicKey"
        },
        "currentSlotNumber": {
          "type": "getCurrentSlot"
        },
        "coin": {
          "type": "data",
          "value": "5000000"
        },
        "datum": {
          "type": "plutusData",
          "data": {
            "fromJSON": {
              "schema": 1,
              "obj": {
                "list": [
                  {
                    "int": 1234
                  },
                  {
                    "bytes": "{get('cache.dependencies.owner.pubKeyHashHex')}"
                  },
                  {
                    "bytes": "{get('cache.dependencies.beneficiary.pubKeyHashHex')}"
                  }
                ]
              }
            }
          }
        },
        "smartContract": {
          "type": "plutusScript",
          "script": {
            "heliosCode": "{replaceAll(hexToStr('0a7370656e64696e672074696d655f6c6f636b0a0a73747275637420446174756d207b0a202020206c6f636b556e74696c3a20202054696d650a202020206f776e65723a202020202020205075624b657948617368202f2f20746865206f776e65722063616e20616c7761797320756e6c6f636b20746865206173736574730a2020202062656e65666963696172793a205075624b657948617368202f2f2062656e65666963696172792063616e206f6e6c7920756e6c6f636b207468652061737365747320616674657220276c6f636b556e74696c270a7d0a0a66756e63206d61696e28646174756d3a20446174756d2c205f2c206374783a20536372697074436f6e7465787429202d3e20426f6f6c207b0a2020202074783a205478203d206374782e74783b0a202020206e6f773a2054696d65203d2074782e74696d655f72616e67652e73746172743b0a0a2020202074782e69735f7369676e65645f627928646174756d2e6f776e657229207c7c20280a202020202020202074782e69735f7369676e65645f627928646174756d2e62656e6566696369617279292026260a20202020202020206e6f77203e20646174756d2e6c6f636b556e74696c0a20202020290a7d0a20202020202020200a636f6e7374204558414d504c455f444154554d203a446174756d203d20446174756d7b0a2020202054696d653a3a6e6577284578616d706c6554696d65292c0a202020205075624b6579486173683a3a6e657728233031323334353637383961626364663031323334353637383961626364663031323334353637383961626364663031323334353637383961292c0a202020205075624b6579486173683a3a6e657728236664636261393837363534333231306664636261393837363534333231306664636261393837363534333231306664636261393837363534290a7d0a0a'),'ExampleTime','1234')}",
            "parameters": [
              "EXAMPLE_DATUM"
            ],
            "version": "0.15.2"
          }
        },
        "smartContractAddress": {
          "type": "buildAddress",
          "name": "smartContractAddress",
          "addr": {
            "spendScriptHashHex": "{get('cache.dependencies.smartContract.scriptHashHex')}",
            "stakePubKeyHashHex": "{get('cache.dependencies.stakeCredential')}"
          }
        }
      }
    },
    "buildLock": {
      "type": "buildTx",
      "name": "LockingTX",
      "tx": {
        "outputs": [
          {
            "address": "{get('cache.dependencies.smartContractAddress')}",
            "datum": {
              "datumHex": "{get('cache.dependencies.datum.dataHex')}"
            },
            "assets": [
              {
                "policyId": "ada",
                "assetName": "ada",
                "quantity": "{get('cache.dependencies.coin')}"
              }
            ],
            "idPattern": "lockedOutput"
          }
        ],
        "requiredSigners": {
          "owner": "{get('cache.dependencies.owner.pubKeyHashHex')}"
        }
      }
    },
    "signLock": {
      "type": "signTxs",
      "namePattern": "signed-lock",
      "txs": [
        "{get('cache.buildLock.txHex')}"
      ],
      "detailedPermissions": false
    },
    "submitLock": {
      "type": "submitTxs",
      "namePattern": "submitted-lock",
      "txs": "{get('cache.signLock')}"
    },
    "wait": {
      "type": "await",
      "until": {
        "beneficiaryTimeLock": {
          "kind": "timer",
          "unit": "seconds",
          "value": 10
        }
      }
    },
    "buildUnlock": {
      "type": "buildTx",
      "name": "UnlockingTX",
      "tx": {
        "ttl": {
          "from": "{get('cache.dependencies.currentSlotNumber')}"
        },
        "inputs": [
          {
            "txHash": "{get('cache.buildLock.txHash')}",
            "index": "{get('cache.buildLock.indexMap.output.lockedOutput')}"
          }
        ],
        "requiredSigners": {
          "beneficiary": "{get('cache.dependencies.beneficiary.pubKeyHashHex')}"
        },
        "witnesses": {
          "plutus": {
            "scripts": [
              {
                "scriptHex": "{get('cache.dependencies.smartContract.scriptHex')}",
                "lang": "{get('cache.dependencies.smartContract.lang')}"
              }
            ]
          }
        },
        "options": {
          "collateralCoinSelection": "LASLAD"
        }
      }
    },
    "signUnlock": {
      "type": "signTxs",
      "namePattern": "signed-unlock",
      "txs": [
        "{get('cache.buildUnlock.txHex')}"
      ],
      "detailedPermissions": false
    },
    "submitUnlock": {
      "type": "submitTxs",
      "namePattern": "submitted-unlock",
      "txs": "{get('cache.signUnlock')}"
    },
    "finally": {
      "type": "script",
      "exportAs": "LockAndRedeem",
      "run": {
        "locks": {
          "type": "macro",
          "run": "{get('cache.dependencies.locks')}"
        },
        "smartContract": {
          "type": "macro",
          "run": "{get('cache.dependencies.smartContract.scriptHex')}"
        },
        "smartContractHash": {
          "type": "macro",
          "run": "{get('cache.dependencies.smartContract.scriptHashHex')}"
        },
        "smartContractAddress": {
          "type": "macro",
          "run": "{get('cache.dependencies.smartContractAddress')}"
        },
        "lockTx": {
          "type": "macro",
          "run": "{get('cache.buildLock.txHash')}"
        },
        "unlockTx": {
          "type": "macro",
          "run": "{get('cache.buildUnlock.txHash')}"
        }
      }
    }
  }
};
                //This is a patch to adapt the return URL of the script to the origin that is hosting this html file.
                //so this way executed scripts data exports can be captured back on dapp side
                gcscript.returnURLPattern  = window.location.origin +  window.location.pathname ;
                const encoded=await gcEncoder(gcscript,useCodec);
                return `${gcApiUrl}${encoded}`;
            }

            updateUI();
        }





        ///////////////////////////
        //// Encoding Helpers /////
        ///////////////////////////

        //https://github.com/blakeembrey/universal-base64/blob/master/src/browser.ts
        function base64Encode(str){
            const percentToByte=(p)=>String.fromCharCode(parseInt(p.slice(1), 16));
            return btoa(encodeURIComponent(str).replace(/%[0-9A-F]{2}/g, percentToByte));
        }
        function base64Decode(str){
            const byteToPercent=(b)=>`%${`00${b.charCodeAt(0).toString(16)}`.slice(-2)}`;
            return decodeURIComponent(Array.from(atob(str), byteToPercent).join(""));
        }
        //https://github.com/blakeembrey/universal-base64url/blob/master/src/index.ts
        function base64urlDecode(str){
            return base64Decode(str.replace(/\-/g, "+").replace(/_/g, "/"));
        }
        function base64urlEncode(str){
            return base64Encode(str)
                .replace(/\//g, "_")
                .replace(/\+/g, "-")
                .replace(/=+$/, "");
        }



        async function base64ToBytes(base64) {
            const res = await fetch("data:application/octet-stream;base64,"+base64);
            return new Uint8Array(await res.arrayBuffer());
        }
        function urlSafeBase64Encode(safeBase64) {
            return safeBase64
                .replace(/\+/g, '-') // Convert '+' to '-'
                .replace(/\//g, '_') // Convert '/' to '_'
                .replace(/=+$/, ''); // Remove ending '='
        };
        function urlSafeBase64Decode(safeBase64,padding=true) {
            // Add removed at end '='
            let unsafeBase64=safeBase64
            if(padding)
                unsafeBase64 += Array(5 - unsafeBase64.length % 4).join('=');
            unsafeBase64 = unsafeBase64
                .replace(/\-/g, '+') // Convert '-' to '+'
                .replace(/\_/g, '/'); // Convert '_' to '/'
            //return new Buffer(unsafeBase64, 'base64');
            return unsafeBase64;
        };
        function compress(string, encoding) {
            const byteArray = new TextEncoder().encode(string);
            const cs = new CompressionStream(encoding);
            const writer = cs.writable.getWriter();
            writer.write(byteArray);
            writer.close();
            return new Response(cs.readable).arrayBuffer();
        }
        function decompress(byteArray, encoding) {
            const cs = new DecompressionStream(encoding);
            const writer = cs.writable.getWriter();
            writer.write(byteArray);
            writer.close();
            return new Response(cs.readable).arrayBuffer().then(function (arrayBuffer) {
                return new TextDecoder().decode(arrayBuffer);
            });
        }
        async function encodeByteArray(array) {
            return new Promise((resolve) => {
                const blob = new Blob([array]);
                const reader = new FileReader();

                reader.onload = (event) => {
                    const dataUrl = event.target.result;
                    const [_, base64] = dataUrl.split(',');

                    resolve(base64);
                };

                reader.readAsDataURL(blob);
            });
        }

        const codecs={
            'gzip':{
                header:'1-',
                encoder:async function(code){
                    var header       = '1-';
                    // Compact JSON
                    var json         = JSON.stringify(code);
                    // Compress JSON with gzip
                    var encoded_data = await compress(json, "gzip")
                    // Base64url encode data
                    var buffer       = await encodeByteArray(encoded_data);
                    var base64String = urlSafeBase64Encode(buffer.toString())
                    var msg          =`${header}${base64String}`;
                    return msg;
                },
                decoder:async function (msg){
                    var header       = '1-';
                    var base64url    = msg.replace(header,'');
                    // base64ToBytes() requires base64 without padding, so we pass padding=false
                    var base64       = urlSafeBase64Decode(base64url,false);
                    var encoded_data = await base64ToBytes(base64)
                    var json         = await decompress(encoded_data,"gzip");
                    var obj          = JSON.parse(json);
                    return obj;
                },
            },
            'json-url-lzma':{
                header:'XQ',
                encoder:async function(code){
                    const lzma   = JsonUrl('lzma'); // JsonUrl is added to the window object 
                    const msg    = await lzma.compress(code);
                    return msg;
                },
                decoder:async function (msg){
                    const lzma   = JsonUrl('lzma');
                    const obj    = await lzma.decompress(msg);
                    return obj;
                },
            },
            'base64url':{
                header:'0-',
                encoder:async function(code){
                    var header       = '0-';
                    var json         = JSON.stringify(code);
                    var base64String = base64urlEncode(json);
                    var msg          =`${header}${base64String}`;
                    return Promise.resolve(msg);
                },
                decoder:async function (msg){
                    var header       = '0-';
                    var base64String = msg.replace(header,'');
                    var json         = base64urlDecode(base64String);
                    var obj          = JSON.parse(json);
                    return Promise.resolve(obj);
                },
            },
        }
        function gcEncoder(obj,codec='gzip'){
            return codecs[codec].encoder(obj);
        }
        function gcDecoder(msg,codec){
            let _useCodec=codec;
            if(!_useCodec)
                Object.keys(codecs).forEach(_codec=>{
                    const header=codecs[_codec].header;
                    if(msg.startsWith(header))
                        _useCodec=_codec;
                });
            return codecs[_useCodec].decoder(msg);
        }


        window.onload = function () {
            main();
        }

    </script>

    <style>
        body {
            background: fixed;
            background-image: linear-gradient(to left top, #097790, #006c8a, #006184, #00567c, #0b4b74, #184878, #26457b, #35417c, #514187, #6f3e8d, #8d378e, #ab2b89);
            font-family: Arial, Helvetica, sans-serif;
            color: rgb(222, 222, 222);
            text-align: center;
            margin: 12px;
        }

        .box {
            background: #332f39;
            margin: auto;
            padding: 30px;
            border: thin solid black;
            border-radius: 30px;
            box-shadow: 0 1px 1px rgba(0,0,0,0.11), 
              0 2px 2px rgba(0,0,0,0.2), 
              0 4px 4px rgba(0,0,0,0.2), 
              0 8px 8px rgba(0,0,0,0.2), 
              0 16px 16px rgba(0,0,0,0.2), 
              0 32px 32px rgba(0,0,0,0.15);
            max-width: 600px;
        }

        a:link {
            color: rgb(174, 47, 174);
        }

        /* visited link */
        a:visited {
            color: rgb(76, 122, 171);
        }

        /* mouse over link */
        a:hover {
            color: rgb(203, 64, 215);
        }

        /* selected link */
        a:active {
            color: blue;
        }
        #errorBox{
            color: #f58000;
            font-weight: bold;
        }
        .console {
            overflow: auto;
            text-align: left;
            background-color: rgb(30, 30, 30);
            color: green;
            min-height: 200px;
            padding: 8px;
            border-radius: 5px;
            box-shadow: inset 0 1px 1px rgba(0,0,0,0.11), 
            inset 5px 2px 2px 2px rgba(0,0,0,0.2), 
            inset 5px 4px 4px rgba(0,0,0,0.2), 
            inset  0 8px 8px rgba(0,0,0,0.2), 
            inset   0 16px 16px rgba(0,0,0,0.2), 
            inset  0 32px 32px rgba(0,0,0,0.15);
        }

        .flexrow {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 10px;
        }

        form{
            width: 100%;
        }
        .a-unstyled, .a-unstyled > *{
            color: inherit;
            text-decoration: none; 
        }
        .a-unstyled:link { color: inherit;text-decoration: none; }
        .a-unstyled:visited { color: inherit;text-decoration: none; }
        .a-unstyled:hover { color: inherit;text-decoration: none; }
        .a-unstyled:active { color: inherit;text-decoration: none; }
        .button {
            display:inline-block;
            background-color: #181818;
            color: rgb(222, 222, 222);
            border: thin solid white;
            width: 100%;
            margin: 10px 0px;
            padding-top: 20px;
            padding-bottom: 20px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 1px 1px rgba(0,0,0,0.11), 
              0 2px 2px rgba(0,0,0,0.2), 
              0 4px 4px rgba(0,0,0,0.2), 
              0 8px 8px rgba(0,0,0,0.2), 
              0 16px 16px rgba(0,0,0,0.11);
            background-color:#734cad60;
        }
        .button:hover {
            background:linear-gradient(to bottom, #734cad 5%, #644b8a 100%);
            background-color:#734cad;
        }
        .button:active {
            position:relative;
            top:1px;
        }

        /* ===== Scrollbar CSS ===== */
        /* Firefox */
        * {
            scrollbar-width: 10px!important;
            scrollbar-color: gray rgb(30, 30, 30,0);
        }

        /* Chrome, Edge, and Safari */
        *::-webkit-scrollbar {
            width: 10px!important;
        }

        *::-webkit-scrollbar-track {
            background: rgb(30, 30, 30,0);
        }

        *::-webkit-scrollbar-thumb {
            background-color: gray;
            border-radius: 10px;
            border: 3px solid rgb(30, 30, 30,0);
        }
    </style>
</head>

<body>
    <div class="box">
        <h1>Helios Timelock</h1>
        <p><i>Builds an Helios Smart Contract on the fly. First transaction will lock coins setting main staking key as owner, second one will be able to unlock it only after some time and using main spending key. Burner/Gift wallets not recommended. Timelock not exactly tested.</i></p>
         
            <div id="dappConnectorBox">
                <a href="#" id="connectBtn" class="button a-unstyled">
                    Loading....
                </a>
            </div>

        <pre id="errorBox"  class="errors"></pre>
        <pre id="resultBox" class="console">Results will appear here after you connect with the wallet</pre>

        <pre id="encodersBox"></pre>

        <h6><i> üí™ Lets turn Cardano into the Blockchain of the Web! üí™ </i> </h6>

        <i>Generated with ‚ù§Ô∏è 
        <br/>
        by <b>
            <a target="_blank" rel="noopener noreferrer" href="http://localhost:3000/playground"> GameChanger Wallet Playground IDE</a>
        </b>
        <br/>
         2023 </i></p>
        </p>

        <h6 class="flexrow">
            <a target="_blank" rel="noopener noreferrer" href="https://twitter.com/GameChangerOk">Twitter News</a> 
            <a target="_blank" rel="noopener noreferrer" href="https://discord.gg/vpbfyRaDKG">Discord Support</a> 
            <a target="_blank" rel="noopener noreferrer" href="https://www.youtube.com/@gamechanger.finance">Youtube Tutorials</a>            
            <a target="_blank" rel="noopener noreferrer" href="https://github.com/GameChangerFinance/gamechanger.wallet/">Github Docs and examples</a>            
            <a target="_blank" rel="noopener noreferrer" href="https://gamechanger.finance">Website</a>
        </h6>
    </div>
</body>

</html>

